[
["2-descriptive-statistics.html", "2 Descriptive Statistics", " 2 Descriptive Statistics "],
["2-1-introduction-to-probablity.html", "2.1 Introduction to Probablity", " 2.1 Introduction to Probablity 2.1.1 Definitions Sample Space: set of all possible outcomes in an experiment or trial Event: any individual outcome of interest, or subset of outcomes of interest, in an experiment or trial Probablity: relative frequency of an event of interest over an indefintely large (or infinite) number of trials 2.1.2 Probablity The true probablity of an event is often unknown and ca only be estimated. Relative frequency probablity: Counting the number of repetitions of a process and the number of times each events occurs - Divide the number of each outcome by the total number of repetitions - This estimates the likelihood of each event occuring -This follows the ideas of bar charts and histograms 2.1.3 Sampling Population: A well defined collection of objects, such as: pregnant women, MS patients, stroke survivors, etc. - Measurements on every member of th population consitutes a census. - A census may not be feasible or desired. Sample: a subset of the populaiton from which characterstics are measured in order to estimate and infer characteristics of the population. - Individual components of the sample are its elements (observations) 2.1.4 Statistics Parameters: fixed values used to describe characteristics of a variable’s distribution (e.g., where it is centered, measures of its spread, measures of its skewness, etc.) Common paramters are the mean and standard deviation. Go back and fix *** 2.1.5 Descriptive Statistics: summary statistics used to estiamte population paramters Sample statistics include \\(\\bar{x}, s^2, s\\) - lower case letters are used for describing samples. Population parameters are estimated from the sample - population parameters include \\(\\mu, \\sigma^s, \\sigma\\) Inferential Statistics Go back and fix *** 2.1.5.1 Describing Data Data are summarized by descriptive statistics, and distributions of variables are often depicted using plots including: -charts -histograms go back and fix *** "],
["2-2-measures-of-location-using-base-r.html", "2.2 Measures of Location using Base R", " 2.2 Measures of Location using Base R Determining the correct method for measuring the central tendancy of a vector depends on the relationship between the numbers within the vector. Numbers that can be summed in a linear sequence are best represented using the arithmic mean. If you’re measuring units that add up as reciprocals in a sequence (such as speed or distance / time over a constant distance, capacitance in series, resistance in parallel), then a harmonic mean will give you a meaningful average. For example, the harmonic mean of capacitors in series represents the capacitance that a single capacitor would have if only one capacitor was used instead of the set of capacitors in series. If you’re measuring units that multiply in a sequence (such as growth rates or percentages), then a geometric mean will give you a meaningful average. For example, the geometric mean of a sequence of different annual interest rates over 10 years represents an interest rate that, if applied constantly for ten years, would produce the same amount growth in principal as the sequence of different annual interest rates over ten years did. Does an arithmetic mean of interest rates have any significance? As a number, sure. But as an “average” interest rate it seems less intuitive because the principal it produces at the end of ten years is much larger than the geometric mean. Similarly, the harmonic mean of interest rates produces a smaller principal, and so is less intuitive. Now consider areas and volumes as a test of understanding. What mean should we use to report the “average” area or volume in a sequence of areas or volumes? Area is measured in units of length squared. Volume is measured in units of length cubed. In a sequence of areas or volumes, we could either add them up linearly and divide or multiply them and take the roots — which is correct? It depends on what we’re measuring. If these areas or volumes are dependent upon each other (e.g., the size of the same microbe at different times), then a geometric mean probably makes more sense. If these areas or volumes are independent of each other (e.g., the size of a house or pool), then an arithmetic mean probably makes more sense. But whatever you decide, when in doubt report that decision. There is nothing worse for a reader than to see an “average” and not know how it was calculated! - Michael F. Martin,Quora Answer 2.2.1 The Arithmetic Mean The arithmetic mean is the sum of all the observations divided by the number of observations. It is written in statistical terms as \\[\\overline{x} = \\frac{1}{n}\\sum^n_{i=1}x_i\\] mean(ChickWeight$weight) [1] 121.8183 2.2.2 The Median The sample median is: If n is odd \\(\\rightarrow\\) \\(\\Big(\\frac{n+1}{2}\\Big)\\text{th}\\) largest observation If n is even \\(\\rightarrow\\) \\(\\Big(\\frac{n}{2}\\Big)\\text{th}\\) and \\(\\Big(\\frac{n}{2}+1\\Big)\\text{th}\\) largest observations median(ChickWeight$weight) ## [1] 103 2.2.3 The Mode The mode is the most frequently occurring value among all observations in the sample. Although it is infrequently used, it is very useful for categorical and discrete data. Since there isn’t a built in R-function for mode, we learn how to write a function to return the mode through a few examples. 2.2.3.1 Functions 2.2.3.1.1 Base R Example The most simple function begins by assigning the output of function() to some character string (e.g. simple_fun) All statements after the function() are referred as the body of the function. function_name &lt;- function(arg1, arg2,...) { #statements return(&quot;some output&quot;) } function_name() # returns NULL ## [1] &quot;some output&quot; Use return() to output the result of the function. return_value &lt;- function(x,y) { z=x-y z=x+y return(z) } return_value(4,5) ## [1] 9 Since our goal is to find the most frequently occurring value in our data-set (ChickWeight), we need to decide the sequence of functions that we need to accomplish this. As you continue to add various R functions to your R tool belt, you will find many possible combinations for the same solution. First, let’s assign the weight column from ChickWeight to x to simplify things. When x is called, the weight column from ChickWeight is returned as a vector. x&lt;-ChickWeight$weight head(x) ## [1] 42 51 59 64 76 93 We can return the size of x using the length function. 578 length(x) ## [1] 578 We can reduce x to return only the unique values by using the unique function. We’ll assign it to y so we can use it later. y &lt;- unique(x) length(y) ## [1] 212 To more easily watch how the functions are working, we will create two data-frames to watch how we are manipulating both x and y. df.x &lt;- data.frame(x) df.y &lt;- data.frame(y) Using the unique values from the x vector we defined as y, we can use the match function to return a vector that replaces each value in x with their position in the y vector (1-212). df.x$position_in_y&lt;-match(x, y) head(df.x, n = 30) ## x position_in_y ## 1 42 1 ## 2 51 2 ## 3 59 3 ## 4 64 4 ## 5 76 5 ## 6 93 6 ## 7 106 7 ## 8 125 8 ## 9 149 9 ## 10 171 10 ## 11 199 11 ## 12 205 12 ## 13 40 13 ## 14 49 14 ## 15 58 15 ## 16 72 16 ## 17 84 17 ## 18 103 18 ## 19 122 19 ## 20 138 20 ## 21 162 21 ## 22 187 22 ## 23 209 23 ## 24 215 24 ## 25 43 25 ## 26 39 26 ## 27 55 27 ## 28 67 28 ## 29 84 17 ## 30 99 29 The output from match can then be simplified using the tabulate function df.y$frequency &lt;- tabulate(df.x$position_in_y) head(df.y) ## y frequency ## 1 42 15 ## 2 51 8 ## 3 59 5 ## 4 64 5 ## 5 76 3 ## 6 93 4 which.max returns the position of the maximum value. which.max(df.y$frequency) ## [1] 43 df.y[43,] #df.y[row,column] ## y frequency ## 43 41 20 Putting it all together, we can do this in one line. df.y[which.max(tabulate(match(x,y))),] ## y frequency ## 43 41 20 y[which.max(tabulate(match(x,y)))] ## [1] 41 Writing this as a function mode &lt;- function(x){ unique_x &lt;- unique(x) result&lt;-unique_x[which.max(tabulate(match(x,unique_x)))] return(result) } mode(x) ## [1] 41 2.2.3.1.2 Tidyverse Example As with most problems in R, we can also find a solution using packages from the Tidyverse. We will therefore use this as an opportunity to introduce some of the basic tenants of Tidyverse functions. In the dplyr package, a typical workflow will combine observations into a single data-frame, aggregate them into groups, manipulate values into new columns, and summaries the data-frame into more simple terms. The piping operator %&gt;% allows for this to be done seamlessly by literally pipping the result of one function into arguments of another function. print(&quot;non-piped text&quot;) ## [1] &quot;non-piped text&quot; library(dplyr) &quot;piped text&quot; %&gt;% print() ## [1] &quot;piped text&quot; To show how this works, we will start with a simple example where we first want to divided the sum of three and some other number (e.g. 2) by seven. Because of the order of operations, the sum of two and three would need to be placed with parenthesis to indicate it happens before dividing by seven. (4+3)/7 # correct ## [1] 1 4 + 3 / 7 # incorrect ## [1] 4.428571 The piping operator allows the order of operations be explicated dictated with manipulations of starting value reading from the left to right. # pipes use the (.) as a placeholder 4 %&gt;% + 3 %&gt;% {./7} # removing the { } returns an error ## [1] 1 Using pipes increases readability of your R-code and it can easily be reused for different starting values. In R Studio, the pipe character can be easily inserted using a keyboard shortcut (Windows:Ctrl+Shift+M, Mac:Cmd+Shift+M). 11 %&gt;% + 3 %&gt;% {./7} ## [1] 2 Plus, the piped workflow can easily be defined by a function by assigning it to some string with a . in the beginning. op_order &lt;- . %&gt;% +3 %&gt;% {./7} op_order(4) ## [1] 1 op_order(11) ## [1] 2 2.2.3.1.2.1 Determining Mode with dplyr Using the ChickWeight data-set as before, we start by outlining the order of operations. Group the data by weights group_by() Tally the number of members within each group and sort by frequency. tally() Select the row with the largest n. slice() Return the corresponding weight. .$weight ChickWeight %&gt;% group_by(weight) %&gt;% tally(sort = TRUE) %&gt;% slice(1) %&gt;% .$weight ## [1] 41 As before, this workflow can be written as a function by placing . between the assignment operator &lt;- and piping operator %&gt;%. mode_cw&lt;-. %&gt;% group_by(weight) %&gt;% tally(sort = TRUE) %&gt;% slice(1) %&gt;% .$weight mode_cw(ChickWeight) ## [1] 41 However, this function will only work on the ChickWeight data-set. mode_cw(mtcars) ## Error in grouped_df_impl(data, unname(vars), drop): Column `weight` is unknown 2.2.4 Geometric Mean The geometric mean is the antilogarithm of \\(\\overline{\\log x}\\), where \\[\\overline{\\log x}= \\frac{1}{n}\\sum^n_{i=1}\\log{x_i}\\] As with mode, there is no function in Base-R for finding the geometric mean. # using values gm1 &lt;- function(x){ n = length(x) gm = exp((1/n)*sum(log(x))) return(gm) } gm2 &lt;- function(x){ return(exp(mean(log(x)))) } gm1(x) ## [1] 103.0853 gm2(x) ## [1] 103.0853 "],
["2-3-measures-of-spread.html", "2.3 Measures of Spread", " 2.3 Measures of Spread 2.3.1 Range The range is the difference between the largest and smallest observations in a sample. 2.3.2 Quantiles/Percentiles The pth percentile is defined by The (k+1)th largest sample point if np/100 is not an integer (where k is the largest integer less than np/100). The average of the (np/100)th and (np/100+1)th largest observations if np/100 is an integer. # 10th and 90th percentile quantile(x = x, probs = c(0.1,0.9)) ## 10% 90% ## 47.7 223.6 2.3.3 The Variance and Standard Deviation \\[s^2 = \\frac{\\sum^n_{i=1}(x-\\bar{x})^2}{n-1}\\] # variance var(x) ## [1] 5051.223 \\[s = \\sqrt{\\frac{\\sum^n_{i=1}(x-\\bar{x})^2}{n-1}}\\] # Standard deviation sd(x) ## [1] 71.07196 2.3.4 The Coefficient of Variation The coefficient of variation (CV) is defined by \\[100\\%\\times\\frac{s}{\\bar{x}}\\] "],
["2-4-grouped-data.html", "2.4 Grouped data", " 2.4 Grouped data bwt &lt;- readr::read_csv(&quot;data/CSV/Birthweight.csv&quot;) bwt ## # A tibble: 100 x 1 ## BWT ## &lt;dbl&gt; ## 1 58 ## 2 120 ## 3 123 ## 4 104 ## 5 121 ## 6 111 ## 7 91 ## 8 104 ## 9 128 ## 10 133 ## # … with 90 more rows Frequency Distribution # starting dataframe (df) bwt %&gt;% # sort df by BWT column arrange(BWT) %&gt;% # counts values in BWT (n) add_count(BWT) %&gt;% # renames n to Frequency rename(Frequency = n) %&gt;% # creating new columns mutate( Cum_Percent = cume_dist(BWT) # returns cumulative percent ) %&gt;% # remove duplicated rows distinct(.) -&gt; freq_tab DT::datatable(freq_tab) "],
["2-5-graphic-methods.html", "2.5 Graphic Methods", " 2.5 Graphic Methods 2.5.1 Bar Graphs Base-R hist(bwt$BWT) ggplot2 library(ggplot2) ggplot(data = bwt,aes(BWT))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;,binwidth = 10)+ ylab(&quot;Count&quot;) 2.5.2 Stem-and-Leaf Plots Base-R stem(bwt$BWT, scale = 2) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 3 | 2 ## 4 | ## 5 | 8 ## 6 | 478 ## 7 | ## 8 | 3556788999 ## 9 | 12344568889 ## 10 | 0123444445567888899 ## 11 | 00122235555556889 ## 12 | 01112222344445567788 ## 13 | 222334557888 ## 14 | 0146 ## 15 | 5 ## 16 | 1 2.5.3 Box Plots Base-R boxplot(bwt$BWT) ggplot2 ggplot(bwt, aes(x = &quot;&quot;,BWT))+geom_boxplot() 2.5.4 Some Useful Probabilistic notation "]
]
